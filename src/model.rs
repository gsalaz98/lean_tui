use serde::*;
use std::fmt::Display;
use tui::{style::{Style, Color, Modifier}, text::Span};

#[derive(Serialize, Deserialize)]
pub enum PacketType
{
    /// Default, unset:
    None = 0,

    /// Base type for backtest and live work
    AlgorithmNode,

    /// Autocomplete Work Packet
    AutocompleteWork,

    /// Result of the Autocomplete Job:
    AutocompleteResult,

    /// Controller->Backtest Node Packet:
    BacktestNode,

    /// Packet out of backtest node:
    BacktestResult,

    /// API-> Controller Work Packet:
    BacktestWork,

    /// Controller -> Live Node Packet:
    LiveNode,

    /// Live Node -> User Packet:
    LiveResult,

    /// API -> Controller Packet:
    LiveWork,

    /// Node -> User Algo Security Types
    SecurityTypes,

    /// Controller -> User Error in Backtest Settings:
    BacktestError,

    /// Nodes -> User Algorithm Status Packet:
    AlgorithmStatus,

    /// API -> Compiler Work Packet:
    BuildWork,

    /// Compiler -> User Build Success
    BuildSuccess,

    /// Compiler -> User, Compile Error
    BuildError,

    /// Node -> User Algorithm Runtime Error
    RuntimeError,

    /// Error is an internal handled error packet inside users algorithm
    HandledError,

    /// Nodes -> User Log Message
    Log,

    /// Nodes -> User Debug Message
    Debug,

    /// Nodes -> User, Order Update Event
    OrderEvent,

    /// Boolean true/false success
    Success,

    /// History live job packets
    History,

    /// Result from a command
    CommandResult,

    /// Hook from git hub
    GitHubHook,

    /// Documentation result from docs server
    DocumentationResult,

    /// Documentation request to the docs server
    Documentation,

    /// Debug packet generated by Lean
    SystemDebug,

    /// Packet containing insights generated by the algorithm
    AlphaResult,

    /// Alpha API -> Controller packet
    AlphaWork,

    /// Alpha Controller -> Alpha Node packet
    AlphaNode,

    /// Packet containing list of algorithms to run as a regression test
    RegressionAlgorithm,

    /// Packet containing a heartbeat
    AlphaHeartbeat,

    /// Used when debugging to send status updates
    DebuggingStatus
}

#[derive(Serialize, Deserialize)]
pub struct BacktestResultPacket {
    #[serde(rename = "eType")]
    pub Type: PacketType,

    /// <summary>
    /// User unique specific channel endpoint to send the packets
    /// </summary>
    #[serde(rename = "sChannel")]
    pub Channel: String,

    /// <summary>
    /// User Id placing this task
    /// </summary>
    #[serde(rename = "iUserID")]
    pub UserId: i32,

    /// <summary>
    /// Project Id of the this task.
    /// </summary>
    #[serde(rename = "iProjectID")]
    pub ProjectId: i32,

    /// <summary>
    /// User Session Id
    /// </summary>
    #[serde(rename = "sSessionID")]
    pub SessionId: String,

    /// <summary>
    /// BacktestId for this result packet
    /// </summary>
    #[serde(rename = "sBacktestID")]
    pub BacktestId: String,

    /// <summary>
    /// Compile Id for the algorithm which generated this result packet.
    /// </summary>
    #[serde(rename = "sCompileID")]
    pub CompileId: String,

    /// <summary>
    /// Start of the backtest period as defined in Initialize() method.
    /// </summary>
    #[serde(rename = "dtPeriodStart")]
    pub PeriodStart: String,

    /// <summary>
    /// End of the backtest period as defined in the Initialize() method.
    /// </summary>
    #[serde(rename = "dtPeriodFinish")]
    pub PeriodFinish: String,

    /// <summary>
    /// DateTime (EST) the user requested this backtest.
    /// </summary>
    #[serde(rename = "dtDateRequested")]
    pub DateRequested: String,

    /// <summary>
    /// DateTime (EST) when the backtest was completed.
    /// </summary>
    #[serde(rename = "dtDateFinished")]
    pub DateFinished: String,

    /// <summary>
    /// Progress of the backtest as a percentage from 0-1 based on the days lapsed from start-finish.
    /// </summary>
    #[serde(rename = "dProgress")]
    pub Progress: f64,

    /// <summary>
    /// Name of this backtest.
    /// </summary>
    #[serde(rename = "sName")]
    pub Name: String,

    /// <summary>
    /// Result data object for this backtest
    /// </summary>
    #[serde(rename = "oResults")]
    pub Results: BacktestResults,

    /// <summary>
    /// Processing time of the algorithm (from moment the algorithm arrived on the algorithm node)
    /// </summary>
    #[serde(rename = "dProcessingTime")]
    pub ProcessingTime: f64,

    /// <summary>
    /// Estimated number of tradeable days in the backtest based on the start and end date or the backtest
    /// </summary>
    #[serde(rename = "iTradeableDates")]
    pub TradeableDates: i32
}

#[derive(Serialize, Deserialize)]
pub enum Empty {}

#[derive(Serialize, Deserialize)]
pub struct BacktestResults {
    #[serde(skip)]
    pub AlphaRuntimeStatistics: Option<Empty>,

    pub Charts: Option<std::collections::HashMap<String, Chart>>,

    pub Orders: Option<std::collections::HashMap<String, Order>>,
    //pub ProfitLoss: std::collections::HashMap<String, f64>
}

#[derive(Serialize, Deserialize)]
pub struct Order {
    pub Id: u64,
    pub ContingentId: i64,
    pub BrokerId: Vec<String>,
    pub Symbol: Symbol,
    pub Price: f64,
    pub PriceCurrency: String,
    pub Time: String,
    pub CreatedTime: String,
    pub LastFillTime: Option<String>,
    pub LastUpdateTime: Option<String>,
    pub CanceledTime: Option<String>,
    pub Quantity: f64,
    pub Type: i32,
    pub Status: i32,

    #[serde(skip)]
    pub TimeInForce: Option<Empty>,

    pub Tag: Option<String>,

    #[serde(skip)]
    pub Properties: Option<Empty>,

    pub SecurityType: i32,
    pub Direction: i32,
    pub Value: f64,

    #[serde(skip)]
    pub OrderSubmissionData: Option<Empty>,

    pub IsMarketable: bool,

    // LimitOrder, StopLimitOrder
    pub LimitPrice: Option<f64>,

    pub StopPrice: Option<f64>,
    pub StopTriggered: Option<bool>,
}

#[derive(Serialize, Deserialize)]
pub struct Symbol {
    pub Value: String,
    pub ID: String,
    pub Permtick: String
}

#[derive(Serialize, Deserialize)]
pub struct Chart {
    pub Name: String,

    #[serde(skip)]
    pub ChartType: i32,

    pub Series: std::collections::HashMap<String, Series>
}

#[derive(Serialize, Deserialize)]
pub struct Series {
    pub Name: String,
    pub Unit: Option<String>,
    pub Index: i32,
    pub Values: Vec<ChartPoint>,
    pub SeriesType: i32,//SeriesType

    #[serde(skip)]
    pub Color: i32,

    pub ScatterMarkerSymbol: ScatterMarkerSymbol,

}

#[derive(Clone, Serialize, Deserialize)]
pub struct ChartPoint {
    pub x: f64,
    pub y: f64
}

/// <summary>
/// Available types of charts
/// </summary>
#[derive(Serialize, Deserialize)]
pub enum SeriesType
{
    /// Line Plot for Value Types
    Line = 0,
    /// Scatter Plot for Chart Distinct Types
    Scatter,
    /// Charts
    Candle,
    /// Bar chart.
    Bar,
    /// Flag indicators
    Flag,
    /// 100% area chart showing relative proportions of series values at each time index
    StackedArea,
    /// Pie chart
    Pie,
    /// Treemap Plot
    Treemap
}

#[derive(Serialize, Deserialize)]
pub enum ScatterMarkerSymbol {
    #[serde(rename = "none")]
    None = 0,

    #[serde(rename = "circle")]
    Circle,

    #[serde(rename = "square")]
    Square,

    #[serde(rename = "diamond")]
    Diamond,

    #[serde(rename = "triangle")]
    Triangle,

    #[serde(rename = "triangle-down")]
    TriangleDown
}

pub enum OrderType {
    /// <summary>
    /// Market Order Type
    /// </summary>
    Market = 0,

    /// <summary>
    /// Limit Order Type
    /// </summary>
    Limit = 1,

    /// <summary>
    /// Stop Market Order Type - Fill at market price when break target price
    /// </summary>
    StopMarket = 2,

    /// <summary>
    /// Stop limit order type - trigger fill once pass the stop price; but limit fill to limit price.
    /// </summary>
    StopLimit = 3,

    /// <summary>
    /// Market on open type - executed on exchange open
    /// </summary>
    MarketOnOpen = 4,

    /// <summary>
    /// Market on close type - executed on exchange close
    /// </summary>
    MarketOnClose = 5,

    /// <summary>
    /// Option Exercise Order Type
    /// </summary>
    OptionExercise = 6
}

impl Order {
    pub fn into_spans<'a>(&self) -> (Span<'a>, Span<'a>, Span<'a>, Span<'a>, Span<'a>) {
        (
            Span::raw(self.Time.clone()),
            Span::styled(OrderType::from(self.Type).to_string(), Style::default().add_modifier(Modifier::BOLD)),
            direction_to_span(self.Direction),
            Span::raw(self.Quantity.to_string()),
            Span::raw(self.Symbol.Value.clone())
        )
    }
}

impl Display for OrderType {
    fn fmt(&self, f: &mut export::Formatter<'_>) -> std::fmt::Result {
        match self {
            OrderType::Limit => write!(f, "LMT"),
            OrderType::Market => write!(f, "MKT"),
            OrderType::MarketOnClose => write!(f, "MKTOC"),
            OrderType::MarketOnOpen => write!(f, "MKTOO"),
            OrderType::OptionExercise => write!(f, "OPTEXC"),
            OrderType::StopMarket => write!(f, "STPMKT"),
            OrderType::StopLimit => write!(f, "STPLMT"),
        }       
    }
}

fn direction_to_span<'a>(direction: i32) -> Span<'a> {
    let (color, display) = if direction == 0 { 
        (Color::Green,
        "BOT".to_string())
    } 
    else if direction == 1 { 
        (Color::Red,
        "SLD".to_string())
    } 
    else { 
        (Color::White,
        "HLD".to_string())
    };

    Span::styled(display, Style::default().add_modifier(Modifier::BOLD).fg(color))
}

impl From<i32> for OrderType {
    fn from(t: i32) -> Self {
        match t {
            0 => OrderType::Market,
            1 => OrderType::Limit,
            2 => OrderType::StopMarket,
            3 => OrderType::StopLimit,
            4 => OrderType::MarketOnOpen,
            5 => OrderType::MarketOnClose,
            6 => OrderType::OptionExercise,
            _ => panic!("Failed to convert {} to OrderType", t)
        }
    }
}

impl OrderType {

}